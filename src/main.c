#include <stdlib.h>
#include <string.h>

#include "pixler.h"
#include "common.h"

#define BG_COLOR 0x17
static const u8 PALETTE[] = {
	BG_COLOR, 0x1D, 0x30, 0x10,
	BG_COLOR, 0x1D, 0x31, 0x11,
	BG_COLOR, 0x1D, 0x3A, 0x1A,
	BG_COLOR, 0x1D, 0x1D, 0x1D,
	
	BG_COLOR, 0x16, 0x2A, 0x1D,
	BG_COLOR, 0x13, 0x28, 0x1D,
	BG_COLOR, 0x1D, 0x30, 0x10,
	BG_COLOR, 0x1D, 0x1D, 0x1D,
};

Gamepad pad1, pad2;

void read_gamepads(void){
	pad1.prev = pad1.value;
	pad1.value = joy_read(0);
	pad1.press = pad1.value & (pad1.value ^ pad1.prev);
	pad1.release = pad1.prev & (pad1.value ^ pad1.prev);
	
	pad2.prev = pad2.value;
	pad2.value = joy_read(1);
	pad2.press = pad2.value & (pad2.value ^ pad2.prev);
	pad2.release = pad2.prev & (pad2.value ^ pad2.prev);
}

void wait_noinput(void){
	while(joy_read(0) || joy_read(1)) px_wait_nmi();
}

static void darken(register const u8* palette, u8 shift){
	for(idx = 0; idx < 32; idx++){
		ix = palette[idx];
		ix -= shift << 4;
		if(ix > 0x40 || ix == 0x0D) ix = 0x1D;
		px_buffer_set_color(idx, ix);
	}
}

void fade_from_black(const u8* palette, u8 delay){
	darken(palette, 4);
	px_wait_frames(delay);
	darken(palette, 3);
	px_wait_frames(delay);
	darken(palette, 2);
	px_wait_frames(delay);
	darken(palette, 1);
	px_wait_frames(delay);
	darken(palette, 0);
}

static const u8 SYMBOL_ATTR[] = {0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01};
static const u8 SYMBOL_CHR[] = {0x8C, 0x8D, 0x8E, 0x8F, 0x8C, 0x8D, 0x8E, 0x8F, 0x9C, 0x9D, 0x9E, 0x9F, 0x9C, 0x9D, 0x9E, 0x9F};

static const u8 SYMBOL_GRID_POSX[] = {
	0,
	44 + 0*32,
	44 + 1*32,
	44 + 2*32,
	44 + 3*32,
	44 + 4*32,
	44 + 5*32,
	0,
};

static const u8 SYMBOL_GRID_POSY[] = {
	0,
	23 + 0*32,
	23 + 1*32,
	23 + 2*32,
	23 + 3*32,
	23 + 4*32,
	23 + 5*32,
	0,
};

static const u8 TILE_BOX[] = {
	0x80, 0x81, 0x82, 0x83,
	0x90, 0x91, 0x92, 0x93,
	0xA0, 0xA1, 0xA2, 0xA3,
	0xB0, 0xB1, 0xB2, 0xB3,
};

static const u8 TILE_CIRCLE[] = {
	0xC0, 0xC1, 0xC2, 0xC3,
	0xD0, 0xD1, 0xD2, 0xD3,
	0xE0, 0xE1, 0xE2, 0xE3,
	0xF0, 0xF1, 0xF2, 0xF3,
};

static const u8* METATILE_CHRS[] = {TILE_BOX, TILE_BOX, TILE_BOX, TILE_CIRCLE, TILE_CIRCLE};
static const u8 METATILE_ATTRS[] = {0x00, 0x55, 0xAA, 0x55, 0xAA};

static const u16 TILE_NT_OFFS[] = {
	0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,
	0x000, 0x000, 0x004, 0x008, 0x00C, 0x010, 0x014, 0x000,
	0x000, 0x080, 0x084, 0x088, 0x08C, 0x090, 0x094, 0x000,
	0x000, 0x100, 0x104, 0x108, 0x10C, 0x110, 0x114, 0x000,
	0x000, 0x180, 0x184, 0x188, 0x18C, 0x190, 0x194, 0x000,
	0x000, 0x200, 0x204, 0x208, 0x20C, 0x210, 0x214, 0x000,
	0x000, 0x280, 0x284, 0x288, 0x28C, 0x290, 0x294, 0x000,
	0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,
};

static const u8 TILE_AT_OFFS[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00,
	0x00, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x00,
	0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x00,
	0x00, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x00,
	0x00, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x00,
	0x00, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// static const u8 GRID_INDICES[] = {
// 	0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
// 	0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
// 	0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E,
// 	0x21, 0x22, 0x23, 0x24, 0x25, 0x26,
// 	0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E,
// 	0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
// };

// TODO Temp data
static u8 SYMBOL_GRID[64] = {
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x1, 0x2, 0x3, 0x0, 0x0, 0x0,
	0x0, 0x4, 0x5, 0x6, 0x7, 0x0, 0x0, 0x0,
	0x0, 0x8, 0x9, 0xA, 0xB, 0x0, 0x0, 0x0,
	0x0, 0xC, 0xD, 0xE, 0xF, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
};

static u8 TILE_GRID[64];

static u8 FOOBAR[512];

static void blit_tile(u8 tile){
	static u8 metatile;
	static u16 nt_offs;
	
	nt_offs = TILE_NT_OFFS[tile];
	metatile = TILE_GRID[tile];
	
	px_buffer_blit((NT_ADDR(0, 0, 0) + 0x00) + nt_offs, METATILE_CHRS[metatile] + 0x0, 4);
	px_buffer_blit((NT_ADDR(0, 0, 0) + 0x20) + nt_offs, METATILE_CHRS[metatile] + 0x4, 4);
	px_buffer_blit((NT_ADDR(0, 0, 0) + 0x40) + nt_offs, METATILE_CHRS[metatile] + 0x8, 4);
	px_buffer_blit((NT_ADDR(0, 0, 0) + 0x60) + nt_offs, METATILE_CHRS[metatile] + 0xC, 4);
	px_buffer_blit(AT_ADDR(0) + TILE_AT_OFFS[tile], METATILE_ATTRS + metatile, 1);
}

#define MOUSE_SPEED 0x280
static u16 mouse_x, mouse_y;

static u8 tile_at_mouse(void){
	u8 x = (mouse_x + 0x0000) >> 13;
	u8 y = (mouse_y + 0x1400) >> 13;
	
	if((u8)(x - 1) < 6 && (u8)(y - 1) < 6){
		return x + 8*y;
	} else {
		return 0;
	}
}

static void gameloop_player(void){
	while(true){
		if(JOY_LEFT (pad1.value)) mouse_x -= MOUSE_SPEED;
		if(JOY_RIGHT(pad1.value)) mouse_x += MOUSE_SPEED;
		if(JOY_DOWN (pad1.value)) mouse_y += MOUSE_SPEED;
		if(JOY_UP   (pad1.value)) mouse_y -= MOUSE_SPEED;
		px_spr(mouse_x >> 8, mouse_y >> 8, 0x02, 0x04);
		
		if(JOY_BTN_B(pad1.press)){
			tmp = tile_at_mouse();
			if(tmp){
				TILE_GRID[tmp] = 1;
				blit_tile(tmp);
			}
		}
		
		px_coro_yield(0);
	}
}

static u8 GAMELOOP_CORO[256];
static uintptr_t gameloop_body(uintptr_t _){
	mouse_x = 0x8000, mouse_y = 0x8000;
	
	while(true){
		gameloop_player();
	}
}

static void splash_screen(void){
	px_ppu_sync_disable();{
		for(ix = 1; ix <= 6; ix++){
			for(iy = 1; iy <= 6; iy++){
				blit_tile(ix + iy*8);
				px_buffer_exec();
			}
		}
	} px_ppu_sync_enable();
	
	PX.scroll_y = 480 - 16;
	PX.scroll_x = -36;
		
	// music_play(0);
	
	fade_from_black(PALETTE, 4);
	
	px_coro_init(gameloop_body, GAMELOOP_CORO, sizeof(GAMELOOP_CORO));
	
	while(true){
		read_gamepads();
		if(px_coro_resume(GAMELOOP_CORO, 0)) break;
		
		for(ix = 1; ix <= 6; ix++){
			for(iy = 1; iy <= 6; iy++){
				idx = SYMBOL_GRID[ix + iy*8] & 0xF;
				px_spr(SYMBOL_GRID_POSX[ix], SYMBOL_GRID_POSY[iy], SYMBOL_ATTR[idx], SYMBOL_CHR[idx]);
			}
		}
		
		px_profile_start();
		px_profile_end();
		px_spr_end();
		px_wait_nmi();
	}
	
	splash_screen();
}

void main(void){
	px_uxrom_select(0);
	joy_install(nes_stdjoy_joy);
	
	px_bg_table(0);
	px_spr_table(0);
	
	// Black out the palette.
	for(idx = 0; idx < 32; idx++) px_buffer_set_color(idx, 0x1D);
	px_wait_nmi();
	
	// Decompress the tileset into character memory.
	px_lz4_to_vram(CHR_ADDR(0, 0), CHR0);
	
	sound_init(&SOUNDS);
	music_init(&MUSIC);
	
	splash_screen();
}
